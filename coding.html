<h1>Jamal's Guide to Coding and Algorithms 2011</h1>
<p>
  This project was created to help people with coding and algorithms.
</p>
<p>
  All the examples presented here are implementations in Java or Python. 
</p>
<p>
  The author takes no responsibility for any misguidance or wrong answers, use at your own peril!
</p>

<title> Jamming to the Coding Interview </title>
<h4>
  Table of Contents
</h4>

<ul>
<li><a href="#interesting-links">Interesting Links</a></li>
<li><a href="#bit-stuff">Bit Stuff</a><ul>
<li><a href="#swapping-a-variable-without-using-a-temporary-variable">Swapping a variable without using a temporary variable</a></li>
</ul></li>
<li><a href="#data-structures">Data Structures</a><ul>
<li><a href="#linked-list">Linked List</a></li>
<li><a href="#binary-search-tree">Binary Search Tree</a></li>
<li><a href="#stack">Stack</a></li>
<li><a href="#hash-tables">Hash Tables</a></li>
</ul></li>
<li><a href="#graphs">Graphs</a><ul>
<li><a href="#general-representation-in-java">General Representation in Java</a></li>
<li><a href="#depth-first-search">Depth First Search</a></li>
<li><a href="#breath-first-search">Breath First Search</a></li>
</ul></li>
<li><a href="#sorting-searching">Sorting &amp; Searching</a><ul>
<li><a href="#binary-search">Binary Search</a></li>
<li><a href="#merge-sort">Merge Sort</a></li>
<li><a href="#insertion-sort">Insertion Sort</a></li>
<li><a href="#quick-sort">Quick Sort</a></li>
</ul></li>
<li><a href="#string-algorithms">String Algorithms</a><ul>
<li><a href="#computing-all-substrings-of-a-string">Computing all substrings of a string</a></li>
<li><a href="#reversing-a-string">Reversing a String</a></li>
<li><a href="#palindrome">Palindrome</a></li>
</ul></li>
</ul>
<h2 id="interesting-links"><a href="#TOC">Interesting Links</a></h2>
<ul>
<li>[Bit Hacks]:<a href="http://graphics.stanford.edu/~seander/bithacks.html"><code class="url">http://graphics.stanford.edu/~seander/bithacks.html</code></a></li>
<li>[XOR Linked Lists]:<a href="http://en.wikipedia.org/wiki/XOR_linked_list"><code class="url">http://en.wikipedia.org/wiki/XOR_linked_list</code></a></li>
</ul>
<h2 id="bit-stuff"><a href="#TOC">Bit Stuff</a></h2>
<h3 id="swapping-a-variable-without-using-a-temporary-variable"><a href="#TOC">Swapping a variable without using a temporary variable</a></h3>
<ul>
<li>This is about taking two variables and and swapping their values.</li>
<li><p>There are two main ways of doing this, one is using XOR and the other is using addition and multiplication</p></li>
<li><p>The addition method is below:</p></li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">swap</span>(){<br /><br />    <span class="dt">int</span> r = <span class="dv">12</span>;<br />    <span class="dt">int</span> s = <span class="dv">5</span>;<br /><br />    System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;r, &quot;</span> +  r + <span class="st">&quot; s, &quot;</span> + s);<br /><br />    r = r + s;<br />    s = r - s;<br />    r = r - s;<br /><br />    System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;r, &quot;</span> +  r + <span class="st">&quot; s, &quot;</span> + s);<br /><br />}</code></pre>
<ul>
<li>The XOR method is below:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">swap</span>(){<br /><br />        <span class="dt">int</span> r = <span class="dv">12</span>;<br />        <span class="dt">int</span> s = <span class="dv">5</span>;<br /><br />        System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;r, &quot;</span> +  r + <span class="st">&quot; s, &quot;</span> + s);<br /><br />        r = r ^ s;<br />        s = r ^ s;<br />        r = r ^ s;<br /><br />        System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;r, &quot;</span> +  r + <span class="st">&quot; s, &quot;</span> + s);<br /><br />    }<br /></code></pre>
<h2 id="data-structures"><a href="#TOC">Data Structures</a></h2>
<h3 id="linked-list"><a href="#TOC">Linked List</a></h3>
<ul>
<li>We use links for the Linked List, so we define a link as follows:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><br /><span class="kw">public</span> <span class="kw">class</span> Link&lt;V&gt;{<br /><br />    <span class="kw">private</span> V value;<br />    <span class="kw">private</span> Link&lt;V&gt; next;<br /><br />    <span class="kw">public</span> <span class="fu">Link</span>(V value) {<br />        <span class="kw">this</span>.<span class="fu">value</span> = value;<br />    }<br /><br />    <span class="kw">public</span> V <span class="fu">getValue</span>() {<br />        <span class="kw">return</span> value;<br />    }<br /><br />    <span class="kw">public</span> Link&lt;V&gt; <span class="fu">getNext</span>() {<br />        <span class="kw">return</span> next;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">setNext</span>(Link&lt;V&gt; next) {<br />        <span class="kw">this</span>.<span class="fu">next</span> = next;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">setValue</span>(V value) {<br />        <span class="kw">this</span>.<span class="fu">value</span> = value;<br />    }<br /><br />}<br /></code></pre>
<ul>
<li>The code for an in order linked list is as follows:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><span class="kw">public</span> <span class="kw">class</span> LinkedList&lt;V <span class="kw">extends</span> Comparable&lt;V&gt;&gt; {<br /><br />    <span class="kw">private</span> Link&lt;V&gt; head;<br />    <span class="kw">private</span> <span class="dt">int</span> size;<br /><br />    <span class="kw">public</span> LinkedList() {<br />        head = <span class="kw">null</span>;<br />        size = <span class="dv">0</span>;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">print</span>(){<br />        Link&lt;V&gt; curr = head;<br />        <span class="kw">while</span> (curr != <span class="kw">null</span>){<br />            System.<span class="fu">out</span>.<span class="fu">println</span>(curr.<span class="fu">getValue</span>());<br />            curr = curr.<span class="fu">getNext</span>();<br />        }<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(V value){<br />        <span class="kw">if</span> (head == <span class="kw">null</span>){<br />            head = <span class="kw">new</span> Link&lt;V&gt;(value);<br />            size++;<br />        }<br />        <span class="kw">else</span> <span class="kw">if</span> (value.<span class="fu">compareTo</span>(head.<span class="fu">getValue</span>()) &lt; <span class="dv">0</span>) {<br />            Link&lt;V&gt; curr = <span class="kw">new</span> Link&lt;V&gt;(value);<br />            curr.<span class="fu">setNext</span>(head);<br />            head = curr;<br />            size++;<br />        }<br />        <span class="kw">else</span> {<br />            Link&lt;V&gt; prev = head;<br />            Link&lt;V&gt; curr = prev.<span class="fu">getNext</span>();<br /><br />            <span class="kw">while</span> (curr != <span class="kw">null</span> &amp;&amp; value.<span class="fu">compareTo</span>(curr.<span class="fu">getValue</span>()) &gt; <span class="dv">0</span>){<br />                prev = curr;<br />                curr = curr.<span class="fu">getNext</span>();<br />            }<br /><br />            prev.<span class="fu">setNext</span>(<span class="kw">new</span> Link&lt;V&gt;(value));<br />            <span class="kw">if</span> (curr != <span class="kw">null</span>)<br />                prev.<span class="fu">getNext</span>().<span class="fu">setNext</span>(curr);<br />            size++;     <br />        }<br /><br />    }<br />}</code></pre>
<h3 id="binary-search-tree"><a href="#TOC">Binary Search Tree</a></h3>
<ul>
<li>Once again Binary Tree nodes are used for a Binary Search Tree and the data structure for a node is below:</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><br /><span class="kw">public</span> <span class="kw">class</span> BTreeEntry&lt;V&gt; {<br /><br />    <span class="kw">private</span> V value;<br />    <span class="kw">private</span> BTreeEntry&lt;V&gt; left;<br />    <span class="kw">private</span> BTreeEntry&lt;V&gt; right;<br /><br />    <span class="kw">public</span> <span class="fu">BTreeEntry</span>(V value) {<br />        <span class="kw">this</span>.<span class="fu">value</span> = value;<br />    }<br />    <span class="kw">public</span> V <span class="fu">getValue</span>(){<br />        <span class="kw">return</span> value;<br />    }<br /><br />    <span class="kw">public</span> BTreeEntry&lt;V&gt; <span class="fu">getRight</span>(){<br />        <span class="kw">return</span> right;<br />    }<br /><br />    <span class="kw">public</span> BTreeEntry&lt;V&gt; <span class="fu">getLeft</span>(){<br />        <span class="kw">return</span> left;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">setRight</span>(BTreeEntry&lt;V&gt; right){<br />        <span class="kw">this</span>.<span class="fu">right</span> = right;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">setLeft</span>(BTreeEntry&lt;V&gt; left){<br />        <span class="kw">this</span>.<span class="fu">left</span> = left;<br />    }<br /><br /><br />}</code></pre>
<ul>
<li>The main code for the Binary Search Tree is below</li>
<li>There are two ways to add, the recursive way (put(), which uses addNode() or the iterative way add())</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><br /><span class="kw">public</span> <span class="kw">class</span> BTree&lt;V <span class="kw">extends</span> Comparable&lt;V&gt;&gt; {<br /><br /><br />    <span class="kw">private</span> BTreeEntry&lt;V&gt; root;<br />    <span class="kw">private</span> <span class="dt">int</span> size;<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">addNode</span>(V value, BTreeEntry&lt;V&gt; node){<br />        <span class="kw">if</span> (node.<span class="fu">getValue</span>().<span class="fu">compareTo</span>(value) &gt;<span class="dv">0</span>){<br />            <span class="kw">if</span> (node.<span class="fu">getLeft</span>() == <span class="kw">null</span>){<br />                node.<span class="fu">setLeft</span>(<span class="kw">new</span> BTreeEntry&lt;V&gt;(value));<br />                size++;<br />                <span class="kw">return</span>;<br />            }<br />            <span class="fu">addNode</span>(value, node.<span class="fu">getLeft</span>());<br />        }<br />        <span class="kw">else</span> {<br />            <span class="kw">if</span> (node.<span class="fu">getRight</span>() == <span class="kw">null</span>){<br />                node.<span class="fu">setRight</span>(<span class="kw">new</span> BTreeEntry&lt;V&gt;(value));<br />                size++;<br />                <span class="kw">return</span>;<br />            }<br />            <span class="fu">addNode</span>(value, node.<span class="fu">getRight</span>());<br />        }<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">put</span>(V value){<br />        <span class="kw">if</span> (root == <span class="kw">null</span>){<br />            root = <span class="kw">new</span> BTreeEntry&lt;V&gt;(value);<br />            size++;<br />        }<br />        <span class="kw">else</span> {<br />            <span class="fu">addNode</span>(value, root);<br />        }<br />    }<br /><br />    <span class="kw">public</span> <span class="fu">BTree</span>() {<br />        size = <span class="dv">0</span>;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(V value){<br />        <span class="kw">if</span> (root == <span class="kw">null</span>){<br />            root = <span class="kw">new</span> BTreeEntry&lt;V&gt;(value);<br />            size++;<br />        }<br />        <span class="kw">else</span> {<br />            BTreeEntry&lt;V&gt; node = root;<br />            <span class="kw">while</span> (node != <span class="kw">null</span>){<br />                <span class="kw">if</span> (node.<span class="fu">getValue</span>().<span class="fu">compareTo</span>(value) &gt; <span class="dv">0</span>){<br />                    <span class="kw">if</span> (node.<span class="fu">getLeft</span>() == <span class="kw">null</span>){<br />                        node.<span class="fu">setLeft</span>(<span class="kw">new</span> BTreeEntry&lt;V&gt;(value));<br />                        size++;<br />                        <span class="kw">return</span>;<br />                    }<br />                    node = node.<span class="fu">getLeft</span>();<br />                }<br />                <span class="kw">else</span> {<br />                    <span class="kw">if</span> (node.<span class="fu">getRight</span>() == <span class="kw">null</span>){<br />                        node.<span class="fu">setRight</span>(<span class="kw">new</span> BTreeEntry&lt;V&gt;(value));<br />                        size++;<br />                        <span class="kw">return</span>;<br />                    }<br />                    node = node.<span class="fu">getRight</span>();<br />                }<br /><br />            }<br />        }<br />    }<br /><br /><br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">printTree</span>(BTreeEntry&lt;V&gt; node){<br />        <span class="kw">if</span> (node != <span class="kw">null</span>){<br />            <span class="fu">printTree</span>(node.<span class="fu">getLeft</span>());<br />            System.<span class="fu">out</span>.<span class="fu">println</span>(node.<span class="fu">getValue</span>());<br />            <span class="fu">printTree</span>(node.<span class="fu">getRight</span>());<br />        }<br />    }<br /><br />}</code></pre>
<h3 id="stack"><a href="#TOC">Stack</a></h3>
<ul>
<li>We will use the same link structure as in the linked list to define a stack.</li>
<li>A stack has two main methods pop and push.</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><span class="kw">public</span> <span class="kw">class</span> Stack&lt;V&gt; {<br /><br /><br />    <span class="kw">private</span> Link&lt;V&gt; head;<br /><br />    <span class="kw">private</span> <span class="dt">int</span> size;<br /><br />    <span class="kw">public</span> Stack() {<br />        head = <span class="kw">null</span>;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">push</span>(V value){<br />        Link&lt;V&gt; link = <span class="kw">new</span> Link&lt;V&gt;(value);<br />        link.<span class="fu">setNext</span>(head);<br />        head = link;<br />        size++;<br />    }<br /><br />    <span class="kw">public</span> Link&lt;V&gt; <span class="fu">pop</span>(){<br />        Link&lt;V&gt; toReturn = head;<br />        head = head.<span class="fu">getNext</span>();<br />        size--;<br />        <span class="kw">return</span> toReturn;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">printStack</span>(){<br />        Link&lt;V&gt; node = head;<br />        <span class="kw">while</span> (node != <span class="kw">null</span>){<br />            System.<span class="fu">out</span>.<span class="fu">println</span>(node.<span class="fu">getValue</span>());<br />            node = node.<span class="fu">getNext</span>();<br />        }<br /><br /><br />    }<br />}<br /></code></pre>
<h3 id="hash-tables"><a href="#TOC">Hash Tables</a></h3>
<ul>
<li>Below is an implemented Hash Table and it's usage.</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><br /><span class="kw">public</span> <span class="kw">class</span> HashTable&lt;V <span class="kw">extends</span> Comparable&lt;V&gt;&gt; {<br /><br /><br />    <span class="kw">private</span> LinkedList&lt;V&gt; [] hashtable;<br />    <span class="kw">private</span> <span class="dt">int</span> size;<br />    <span class="kw">private</span> <span class="dt">final</span> <span class="dt">int</span> LIMIT = <span class="dv">26</span>;<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(V value){<br />        <span class="kw">if</span> (hashtable[<span class="fu">hash</span>(value)] == <span class="kw">null</span>) {<br />            hashtable[<span class="fu">hash</span>(value)] = <span class="kw">new</span> LinkedList&lt;V&gt;();<br />            hashtable[<span class="fu">hash</span>(value)].<span class="fu">add</span>(value);<br />        }<br />        <span class="kw">else</span> {<br />            hashtable[<span class="fu">hash</span>(value)].<span class="fu">add</span>(value);<br />        }<br />        size++;<br />    }<br /><br />    <span class="kw">public</span> <span class="fu">HashTable</span>() {<br />        hashtable = <span class="kw">new</span> LinkedList [LIMIT]; <br />    }<br /><br /><br />    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">hash</span>(V value){<br />        <span class="kw">return</span> (value.<span class="fu">toString</span>().<span class="fu">charAt</span>(<span class="dv">0</span>)) % LIMIT;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">printTable</span>(){<br /><br />        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span> ; i&lt;LIMIT;i++){<br />            System.<span class="fu">out</span>.<span class="fu">println</span>(i + <span class="st">&quot;:&quot;</span>);<br />            <span class="kw">if</span> (hashtable[i] != <span class="kw">null</span>){<br />                hashtable[i].<span class="fu">print</span>();<br />            }<br />            <span class="kw">else</span> {<br /><br />            }<br />        }<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) {<br />        HashTable&lt;String&gt; table = <span class="kw">new</span> HashTable&lt;String&gt;();<br />        table.<span class="fu">add</span>(<span class="st">&quot;Jamal&quot;</span>);<br />        table.<span class="fu">add</span>(<span class="st">&quot;Rafal&quot;</span>);<br />        table.<span class="fu">add</span>(<span class="st">&quot;Danish&quot;</span>);<br />        table.<span class="fu">add</span>(<span class="st">&quot;Alessandro&quot;</span>);<br />        table.<span class="fu">add</span>(<span class="st">&quot;Alex&quot;</span>);<br />        table.<span class="fu">printTable</span>();<br />    }<br /><br /><br />}</code></pre>
<h2 id="graphs"><a href="#TOC">Graphs</a></h2>
<h3 id="general-representation-in-java"><a href="#TOC">General Representation in Java</a></h3>
<ul>
<li>Below is the representation I will use of a node, a graph and a visited structure.</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><span class="co">/*</span><br /><span class="co"> *  Node representation </span><br /><span class="co"> */</span><br /><br /><span class="kw">class</span> Node&lt;V&gt; <span class="kw">implements</span> Comparable&lt;Node&gt;{<br /><br />        String value;<br /><br />        <span class="kw">public</span> Node(String value) {<br />            <span class="kw">this</span>.<span class="fu">value</span> = value;<br />        }<br />        <span class="kw">public</span> String <span class="fu">getValue</span>(){<br />            <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">value</span>;<br />        }<br />        <span class="kw">public</span> <span class="dt">void</span> <span class="fu">setValue</span>(String value){<br />            <span class="kw">this</span>.<span class="fu">value</span> = value;<br />        }<br />        <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compareTo</span>(Node node) {<br />            <span class="kw">return</span> <span class="kw">this</span>.<span class="fu">value</span>.<span class="fu">compareTo</span>(node.<span class="fu">value</span>);<br />        }<br /><br /><br />}<br /><br /><span class="co">/*</span><br /><span class="co"> * Graph representation</span><br /><span class="co"> */</span><br /><br /><span class="kw">private</span> <span class="dt">static</span> HashMap&lt;Node, ArrayList&lt;Node&gt;&gt; graph;<br /><br /><span class="co">/* </span><br /><span class="co"> * Visited structure for recording whether a node is visited or not</span><br /><span class="co"> */</span><br /><br /><span class="kw">private</span> <span class="dt">static</span> HashMap&lt;Node, Boolean&gt; visited;  </code></pre>
<h3 id="depth-first-search"><a href="#TOC">Depth First Search</a></h3>
<pre class="sourceCode"><code class="sourceCode java"><br /><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">DFS</span>(Node n){<br /><br />        visited.<span class="fu">put</span>(n, <span class="kw">true</span>);<br />        System.<span class="fu">out</span>.<span class="fu">println</span>(n.<span class="fu">s</span>);<br /><br />        <span class="kw">for</span> (Node node : graph.<span class="fu">get</span>(n)){<br />            <span class="kw">if</span> (!visited.<span class="fu">get</span>(node)){<br />                visited.<span class="fu">put</span>(node, <span class="kw">true</span>);<br />                <span class="fu">DFS</span>(node);<br />            }<br />        }<br /><br />    }</code></pre>
<h3 id="breath-first-search"><a href="#TOC">Breath First Search</a></h3>
<pre class="sourceCode"><code class="sourceCode java"><br /><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">BFS</span>(Node n){<br />        Queue&lt;Node&gt; q = <span class="kw">new</span> LinkedList&lt;Node&gt;();<br />        q.<span class="fu">add</span>(n);<br />        visited.<span class="fu">put</span>(n, <span class="kw">true</span>);<br />        System.<span class="fu">out</span>.<span class="fu">println</span>(n.<span class="fu">s</span>);<br /><br />        <span class="kw">while</span> (!q.<span class="fu">isEmpty</span>()){<br />            Node current = q.<span class="fu">remove</span>();<br />            <span class="kw">for</span> (Node r : graph.<span class="fu">get</span>(current)){<br />                <span class="kw">if</span> (!visited.<span class="fu">get</span>(r)){<br />                    visited.<span class="fu">put</span>(r, <span class="kw">true</span>);<br />                    System.<span class="fu">out</span>.<span class="fu">println</span>(r.<span class="fu">s</span>);<br />                    q.<span class="fu">add</span>(r);<br />                }<br />            }<br />        }<br /><br />}<br /></code></pre>
<h2 id="sorting-searching"><a href="#TOC">Sorting &amp; Searching</a></h2>
<h3 id="binary-search"><a href="#TOC">Binary Search</a></h3>
<ul>
<li>Complexity is O(n)</li>
</ul>
<p>Solution</p>
<pre class="sourceCode"><code class="sourceCode java"><span class="dt">int</span> <span class="fu">bSearch</span>(<span class="dt">int</span> n, <span class="dt">int</span> [] array, <span class="dt">int</span> start, <span class="dt">int</span> end){<br /><br />  <span class="kw">if</span> (start &lt; end){<br />    <span class="dt">int</span> middle = (start + end) / <span class="dv">2</span>;<br />    <span class="kw">if</span> (array[middle] == n)<br />      <span class="kw">return</span> middle;<br />    <span class="kw">else</span> <span class="kw">if</span> (array[middle] &lt; n)<br />      <span class="fu">bSearch</span>(n, array, middle<span class="dv">+1</span>, end);<br />    <span class="kw">else</span><br />      <span class="fu">bSearch</span>(n, array, start, middle<span class="dv">-1</span>);<br />  }<br />  <span class="kw">return</span> -<span class="dv">1</span><br /><br />}</code></pre>
<h3 id="merge-sort"><a href="#TOC">Merge Sort</a></h3>
<ul>
<li>Complexity is 0(n*log(n))</li>
</ul>
<pre class="sourceCode"><code class="sourceCode python"><br /><span class="kw">def</span> mergeSort(array):<br /><br />  <span class="kw">if</span> (<span class="dt">len</span>(array)) == <span class="dv">1</span>):<br />    <span class="kw">return</span> array<br /><br />  half = <span class="dt">len</span>(array)/<span class="dv">2</span><br />  left = []<br />  right = []<br /><br />  <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">0</span>, half):<br />    left.append(array[i])<br /><br />  <span class="kw">for</span> i in <span class="dt">range</span>(half, <span class="dt">len</span>(A)):<br />    right.append(array[i])<br /><br />  <span class="kw">return</span> merge(mergeSort(left), mergeSort(right))<br /><br /><span class="kw">def</span> merge(left, right):<br /><br />  result = []<br /><br />  <span class="kw">while</span> <span class="dt">len</span>(left) &gt; <span class="dv">0</span> || <span class="dt">len</span>(right) &gt;<span class="dv">0</span>:<br />    <span class="kw">if</span> <span class="dt">len</span>(left) &gt; <span class="dv">0</span> &amp;&amp; <span class="dt">len</span>(right) &gt; <span class="dv">0</span>:<br />      <span class="kw">if</span> left[<span class="dv">0</span>] &gt; right[<span class="dv">0</span>]:<br />        result.append(left[<span class="dv">0</span>])<br />        left = left[<span class="dv">1</span>:]<br />      <span class="kw">else</span>:<br />        result.append(right[<span class="dv">0</span>])<br />        right = right[<span class="dv">1</span>:]<br />    <span class="kw">elif</span> <span class="dt">len</span>(left) &gt; <span class="dv">0</span>:<br />      result.append(left[<span class="dv">0</span>])<br />      left = left[<span class="dv">1</span>:]<br />    <span class="kw">else</span><br />      result.append(right[<span class="dv">0</span>])<br />      right = right[<span class="dv">1</span>:]<br /><br />  <span class="kw">return</span> result</code></pre>
<h3 id="insertion-sort"><a href="#TOC">Insertion Sort</a></h3>
<pre class="sourceCode"><code class="sourceCode python"><br /><span class="kw">def</span> insertionSort(a):<br />  <span class="kw">for</span> i in <span class="dt">range</span> (<span class="dv">1</span>, <span class="dt">len</span>(a)):<br />    value = a[i]<br />    j = i - <span class="dv">1</span><br />    done = <span class="ot">False</span><br />    <span class="kw">while</span> done == <span class="ot">False</span>:<br />      <span class="kw">if</span> a[j] &gt; a[j<span class="dv">+1</span>]:<br />        a[j<span class="dv">+1</span>] = a[j]<br />        j = j - <span class="dv">1</span><br />        <span class="kw">if</span> j &lt; <span class="dv">0</span>:<br />          done = <span class="ot">True</span><br />      <span class="kw">else</span>:<br />        done = <span class="ot">True</span><br />      a[j<span class="dv">+1</span>] = value<br />  <span class="kw">return</span> a</code></pre>
<h3 id="quick-sort"><a href="#TOC">Quick Sort</a></h3>
<pre class="sourceCode"><code class="sourceCode python"><br /><span class="kw">def</span> quickSort(a, start, end):<br /><br />  <span class="kw">if</span> (start &lt; end):<br />    pivot = a[end]<br />    p = start<br />    <span class="kw">for</span> i in <span class="dt">range</span>(start, end):<br />      <span class="kw">if</span> a[i] &lt; pivot:<br />        swap(a, i, p)<br />        p = p + <span class="dv">1</span><br />        swap(a, p, end)<br /><br />      quickSort(a, start, p<span class="dv">-1</span>)<br />      quickSort(a, p<span class="dv">+1</span>, end)<br /><br />  <span class="kw">return</span> a<br /><br /><span class="kw">def</span> swap(a, i, j):<br />  n = a[i]<br />  a[i] = a[j]<br />  a[j] = n</code></pre>
<h2 id="string-algorithms"><a href="#TOC">String Algorithms</a></h2>
<h3 id="computing-all-substrings-of-a-string"><a href="#TOC">Computing all substrings of a string</a></h3>
<pre class="sourceCode"><code class="sourceCode java"><br /><span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">subStrings</span>(String s){<br /><br />        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; s.<span class="fu">length</span>(); i++){<br />            <span class="kw">for</span> (<span class="dt">int</span> j = i; j &lt; s.<span class="fu">length</span>(); j++){<br />                System.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">substring</span>(i, j<span class="dv">+1</span>));<br />            }<br />        }<br /><br />}</code></pre>
<h3 id="reversing-a-string"><a href="#TOC">Reversing a String</a></h3>
<ul>
<li>Code in Java is as follows</li>
<li>New one</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br /><span class="co">/*</span><br /><span class="co"> * Takes an array together with two numbers and swaps the two characters</span><br /><span class="co"> * at the particular place.</span><br /><span class="co"> */</span><br /><span class="kw">private</span> <span class="dt">static</span> <span class="dt">char</span> [] <span class="fu">swap</span>(<span class="dt">char</span> [] string, <span class="dt">int</span> i, <span class="dt">int</span> j){<br /><br />    <span class="dt">char</span> c = string[i];<br />    string[i] = string[j];<br />    string[j] = c;<br /><br />    <span class="kw">return</span> string;<br />}<br /><br /><span class="co">/*</span><br /><span class="co"> * Takes a particular word without spaces and swaps reverses it</span><br /><span class="co"> */</span><br /><span class="kw">public</span> <span class="dt">static</span> <span class="dt">char</span> []  <span class="fu">reverseWord</span>(<span class="dt">char</span> [] string, <span class="dt">int</span> start, <span class="dt">int</span> end){<br /><br />    <span class="kw">for</span> (<span class="dt">int</span> i = start; i&lt;=(start+end)/<span class="dv">2</span>; i++){<br />        <span class="fu">swap</span>(string, i, end-(i-start));<br />    }<br />    <span class="kw">return</span> string;<br />}<br /><br /><span class="co">/*</span><br /><span class="co"> * Given a particular sentence with (with no fullstop) reverses the ordering</span><br /><span class="co"> * of the words in it and returns a char array.</span><br /><span class="co"> * </span><br /><span class="co"> */</span><br /><br /><span class="kw">private</span> <span class="dt">static</span> <span class="dt">char</span>[] <span class="fu">reverseSentence</span>(<span class="dt">char</span> [] string){<br />    <span class="dt">char</span> [] reversedSentence = <span class="fu">reverseWord</span>(string, <span class="dv">0</span>, string.<span class="fu">length</span><span class="dv">-1</span>);<br /><br />    System.<span class="fu">out</span>.<span class="fu">println</span>(reversedSentence);<br /><br />    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;reversedSentence.<span class="fu">length</span>; i++){<br />        <span class="dt">int</span> j = i;<br /><br /><br />        <span class="kw">while</span> ((!(reversedSentence[i] == ' ')) &amp;&amp; i &lt; reversedSentence.<span class="fu">length</span><span class="dv">-1</span>)<br />            i++;<br /><br />        <span class="kw">if</span> ( reversedSentence[i] == ' ')<br />            <span class="fu">reverseWord</span>(reversedSentence, j, i<span class="dv">-1</span>);<br />        <span class="kw">else</span> <br />            <span class="fu">reverseWord</span>(string, j, i);<br />    }<br /><br />    <span class="kw">return</span> reversedSentence;<br />}<br /><br /><br /></code></pre>
<h3 id="palindrome"><a href="#TOC">Palindrome</a></h3>
<ul>
<li>Two functions are below:</li>
<li>One is for checking if a string is a palindrome</li>
<li>The second is for printing all palindromes in a string</li>
</ul>
<pre class="sourceCode"><code class="sourceCode java"><br />  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">boolean</span> <span class="fu">isPalindrome</span>(String s){<br />        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;s.<span class="fu">length</span>()/<span class="dv">2</span>; i++){<br />            <span class="kw">if</span> (s.<span class="fu">charAt</span>(i) != s.<span class="fu">charAt</span>(s.<span class="fu">length</span>()-(i<span class="dv">+1</span>)))<br />                <span class="kw">return</span> <span class="kw">false</span>;<br />        }<br />        <span class="kw">return</span> <span class="kw">true</span>;<br />    }<br /><br />    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">getPalindrome</span>(String s){<br /><br />    HashMap&lt;String, Integer&gt; p = <span class="kw">new</span> HashMap&lt;String, Integer&gt;();<br />    String d =<span class="st">&quot;&quot;</span>;<br /><br />    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i&lt;s.<span class="fu">length</span>(); i++){<br />        <span class="kw">for</span> (<span class="dt">int</span> j = i<span class="dv">+1</span>; j &lt; s.<span class="fu">length</span>(); j++){<br /><br />            d = s.<span class="fu">substring</span>(i, j<span class="dv">+1</span>);<br /><br />            <span class="kw">if</span> (<span class="fu">isPalindrome</span>(d)){<br />                <span class="kw">if</span> (p.<span class="fu">containsKey</span>(d))<br />                    p.<span class="fu">put</span>(d, p.<span class="fu">get</span>(d)+<span class="dv">1</span>);<br />                <span class="kw">else</span><br />                    p.<span class="fu">put</span>(d, <span class="dv">1</span>);<br /><br />            }<br />        }<br />    }<br /><br />    <span class="kw">for</span> (String r : p.<span class="fu">keySet</span>()){<br />        System.<span class="fu">out</span>.<span class="fu">println</span>(r + <span class="st">&quot;, &quot;</span> + p.<span class="fu">get</span>(r));<br />    }<br /><br />}<br /><br /></code></pre>


<LINK href="markdown.css" rel="stylesheet" type="text/css">